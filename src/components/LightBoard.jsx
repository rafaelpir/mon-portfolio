import React, { useState, useEffect, useMemo, useCallback } from 'react';

// Font bitmap pour les caractères (5x7 pixels)
const FONT = {
  'A': [0x1E,0x09,0x09,0x1E,0x09,0x09,0x09],
  'B': [0x0F,0x09,0x09,0x0F,0x09,0x09,0x0F],
  'C': [0x0E,0x01,0x01,0x01,0x01,0x01,0x0E],
  'D': [0x0F,0x11,0x11,0x11,0x11,0x11,0x0F],
  'E': [0x1F,0x01,0x01,0x0F,0x01,0x01,0x1F],
  'F': [0x1F,0x01,0x01,0x0F,0x01,0x01,0x01],
  'G': [0x0E,0x01,0x01,0x1D,0x11,0x11,0x0E],
  'H': [0x09,0x09,0x09,0x0F,0x09,0x09,0x09],
  'I': [0x07,0x02,0x02,0x02,0x02,0x02,0x07],
  'J': [0x1C,0x08,0x08,0x08,0x08,0x09,0x06],
  'K': [0x09,0x05,0x03,0x01,0x03,0x05,0x09],
  'L': [0x01,0x01,0x01,0x01,0x01,0x01,0x1F],
  'M': [0x11,0x1B,0x15,0x11,0x11,0x11,0x11],
  'N': [0x11,0x13,0x15,0x19,0x11,0x11,0x11],
  'O': [0x0E,0x11,0x11,0x11,0x11,0x11,0x0E],
  'P': [0x0F,0x11,0x11,0x0F,0x01,0x01,0x01],
  'Q': [0x0E,0x11,0x11,0x11,0x15,0x09,0x16],
  'R': [0x0F,0x11,0x11,0x0F,0x05,0x09,0x11],
  'S': [0x1E,0x01,0x01,0x0E,0x10,0x10,0x0F],
  'T': [0x1F,0x04,0x04,0x04,0x04,0x04,0x04],
  'U': [0x11,0x11,0x11,0x11,0x11,0x11,0x0E],
  'V': [0x11,0x11,0x11,0x11,0x0A,0x0A,0x04],
  'W': [0x11,0x11,0x11,0x15,0x15,0x0A,0x0A],
  'X': [0x11,0x11,0x0A,0x04,0x0A,0x11,0x11],
  'Y': [0x11,0x11,0x0A,0x04,0x04,0x04,0x04],
  'Z': [0x1F,0x10,0x08,0x04,0x02,0x01,0x1F],
  '0': [0x0E,0x11,0x19,0x15,0x13,0x11,0x0E],
  '1': [0x04,0x06,0x04,0x04,0x04,0x04,0x0E],
  '2': [0x0E,0x11,0x10,0x08,0x04,0x02,0x1F],
  '3': [0x1F,0x08,0x04,0x08,0x10,0x11,0x0E],
  '4': [0x08,0x0C,0x0A,0x09,0x1F,0x08,0x08],
  '5': [0x1F,0x01,0x0F,0x10,0x10,0x11,0x0E],
  '6': [0x0C,0x02,0x01,0x0F,0x11,0x11,0x0E],
  '7': [0x1F,0x10,0x08,0x04,0x02,0x02,0x02],
  '8': [0x0E,0x11,0x11,0x0E,0x11,0x11,0x0E],
  '9': [0x0E,0x11,0x11,0x1E,0x10,0x08,0x06],
  ' ': [0x00,0x00,0x00,0x00,0x00,0x00,0x00],
  '.': [0x00,0x00,0x00,0x00,0x00,0x00,0x02],
  ',': [0x00,0x00,0x00,0x00,0x00,0x04,0x02],
  '!': [0x02,0x02,0x02,0x02,0x02,0x00,0x02],
  '?': [0x0E,0x11,0x10,0x08,0x04,0x00,0x04],
  '-': [0x00,0x00,0x00,0x0E,0x00,0x00,0x00],
  "'": [0x02,0x02,0x01,0x00,0x00,0x00,0x00],
  ':': [0x00,0x02,0x00,0x00,0x00,0x02,0x00],
  '/': [0x10,0x08,0x08,0x04,0x02,0x02,0x01],
  'À': [0x04,0x0A,0x1E,0x09,0x09,0x1E,0x09],
};

const CHAR_WIDTH = 5;
const CHAR_HEIGHT = 7;
const CHAR_SPACING = 1;

export const LightBoardSize = {
  Small: 'small',
  Medium: 'medium',
  Large: 'large',
};

const sizeMap = {
  small: { lightSize: 2, gap: 1, rows: 7 },
  medium: { lightSize: 3, gap: 1, rows: 7 },
  large: { lightSize: 4, gap: 1, rows: 7 },
};

export default function LightBoard({
  text = "HELLO WORLD",
  size = LightBoardSize.Medium,
  lightSize: customLightSize,
  gap: customGap,
  updateInterval = 100,
  colorOn = "#E8DCC4",
  colorOff = "rgba(255,255,255,0.05)",
  className = "",
}) {
  const config = sizeMap[size] || sizeMap.medium;
  const lightSize = customLightSize || config.lightSize;
  const gap = customGap || config.gap;
  const rows = CHAR_HEIGHT;

  const [offset, setOffset] = useState(0);

  // Convertir le texte en pattern
  const pattern = useMemo(() => {
    const upperText = text.toUpperCase();
    const totalWidth = upperText.length * (CHAR_WIDTH + CHAR_SPACING);
    const grid = Array(rows).fill(null).map(() => Array(totalWidth).fill(0));

    let x = 0;
    for (const char of upperText) {
      const charData = FONT[char] || FONT[' '];
      for (let row = 0; row < CHAR_HEIGHT; row++) {
        const rowData = charData[row] || 0;
        for (let col = 0; col < CHAR_WIDTH; col++) {
          if (rowData & (1 << (CHAR_WIDTH - 1 - col))) {
            grid[row][x + col] = 1;
          }
        }
      }
      x += CHAR_WIDTH + CHAR_SPACING;
    }
    return grid;
  }, [text, rows]);

  const cols = pattern[0]?.length || 0;

  // Animation de défilement
  useEffect(() => {
    const interval = setInterval(() => {
      setOffset(prev => (prev + 1) % (cols * 2));
    }, updateInterval);
    return () => clearInterval(interval);
  }, [cols, updateInterval]);

  // Calculer les colonnes visibles (double pour boucle infinie)
  const visibleCols = cols * 2;
  const doublePattern = pattern.map(row => [...row, ...row]);

  return (
    <div
      className={`inline-block overflow-hidden ${className}`}
      style={{
        display: 'grid',
        gridTemplateColumns: `repeat(${visibleCols}, ${lightSize}px)`,
        gap: `${gap}px`,
      }}
    >
      {doublePattern.map((row, rowIndex) =>
        row.map((cell, colIndex) => {
          const adjustedCol = (colIndex + offset) % visibleCols;
          const isOn = doublePattern[rowIndex][adjustedCol];
          return (
            <div
              key={`${rowIndex}-${colIndex}`}
              style={{
                width: lightSize,
                height: lightSize,
                borderRadius: '50%',
                backgroundColor: isOn ? colorOn : colorOff,
                boxShadow: isOn ? `0 0 ${lightSize * 2}px ${colorOn}` : 'none',
                transition: 'background-color 0.1s, box-shadow 0.1s',
              }}
            />
          );
        })
      )}
    </div>
  );
}
